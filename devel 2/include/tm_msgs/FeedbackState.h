// Generated by gencpp from file tm_msgs/FeedbackState.msg
// DO NOT EDIT!


#ifndef TM_MSGS_MESSAGE_FEEDBACKSTATE_H
#define TM_MSGS_MESSAGE_FEEDBACKSTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace tm_msgs
{
template <class ContainerAllocator>
struct FeedbackState_
{
  typedef FeedbackState_<ContainerAllocator> Type;

  FeedbackState_()
    : header()
    , is_svr_connected(false)
    , is_sct_connected(false)
    , tmsrv_cperr(0)
    , tmscript_cperr(0)
    , tmsrv_dataerr(0)
    , tmscript_dataerr(0)
    , max_not_connect_in_s(0)
    , disconnection_times(0)
    , joint_pos()
    , joint_vel()
    , joint_tor()
    , tool0_pose()
    , tool_pose()
    , tcp_speed()
    , tcp_force()
    , joint_tor_average()
    , joint_tor_min()
    , joint_tor_max()
    , robot_link(false)
    , is_data_table_correct(false)
    , robot_error(false)
    , project_run(false)
    , project_pause(false)
    , safetyguard_a(false)
    , e_stop(false)
    , camera_light(false)
    , error_code(0)
    , project_speed(0)
    , ma_mode(0)
    , robot_light(0)
    , cb_digital_output()
    , cb_digital_input()
    , cb_analog_output()
    , cb_analog_input()
    , ee_digital_output()
    , ee_digital_input()
    , ee_analog_output()
    , ee_analog_input()
    , error_content()  {
    }
  FeedbackState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , is_svr_connected(false)
    , is_sct_connected(false)
    , tmsrv_cperr(0)
    , tmscript_cperr(0)
    , tmsrv_dataerr(0)
    , tmscript_dataerr(0)
    , max_not_connect_in_s(0)
    , disconnection_times(0)
    , joint_pos(_alloc)
    , joint_vel(_alloc)
    , joint_tor(_alloc)
    , tool0_pose(_alloc)
    , tool_pose(_alloc)
    , tcp_speed(_alloc)
    , tcp_force(_alloc)
    , joint_tor_average(_alloc)
    , joint_tor_min(_alloc)
    , joint_tor_max(_alloc)
    , robot_link(false)
    , is_data_table_correct(false)
    , robot_error(false)
    , project_run(false)
    , project_pause(false)
    , safetyguard_a(false)
    , e_stop(false)
    , camera_light(false)
    , error_code(0)
    , project_speed(0)
    , ma_mode(0)
    , robot_light(0)
    , cb_digital_output(_alloc)
    , cb_digital_input(_alloc)
    , cb_analog_output(_alloc)
    , cb_analog_input(_alloc)
    , ee_digital_output(_alloc)
    , ee_digital_input(_alloc)
    , ee_analog_output(_alloc)
    , ee_analog_input(_alloc)
    , error_content(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _is_svr_connected_type;
  _is_svr_connected_type is_svr_connected;

   typedef uint8_t _is_sct_connected_type;
  _is_sct_connected_type is_sct_connected;

   typedef int32_t _tmsrv_cperr_type;
  _tmsrv_cperr_type tmsrv_cperr;

   typedef int32_t _tmscript_cperr_type;
  _tmscript_cperr_type tmscript_cperr;

   typedef int32_t _tmsrv_dataerr_type;
  _tmsrv_dataerr_type tmsrv_dataerr;

   typedef int32_t _tmscript_dataerr_type;
  _tmscript_dataerr_type tmscript_dataerr;

   typedef int32_t _max_not_connect_in_s_type;
  _max_not_connect_in_s_type max_not_connect_in_s;

   typedef int32_t _disconnection_times_type;
  _disconnection_times_type disconnection_times;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _joint_pos_type;
  _joint_pos_type joint_pos;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _joint_vel_type;
  _joint_vel_type joint_vel;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _joint_tor_type;
  _joint_tor_type joint_tor;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _tool0_pose_type;
  _tool0_pose_type tool0_pose;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _tool_pose_type;
  _tool_pose_type tool_pose;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _tcp_speed_type;
  _tcp_speed_type tcp_speed;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _tcp_force_type;
  _tcp_force_type tcp_force;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _joint_tor_average_type;
  _joint_tor_average_type joint_tor_average;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _joint_tor_min_type;
  _joint_tor_min_type joint_tor_min;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _joint_tor_max_type;
  _joint_tor_max_type joint_tor_max;

   typedef uint8_t _robot_link_type;
  _robot_link_type robot_link;

   typedef uint8_t _is_data_table_correct_type;
  _is_data_table_correct_type is_data_table_correct;

   typedef uint8_t _robot_error_type;
  _robot_error_type robot_error;

   typedef uint8_t _project_run_type;
  _project_run_type project_run;

   typedef uint8_t _project_pause_type;
  _project_pause_type project_pause;

   typedef uint8_t _safetyguard_a_type;
  _safetyguard_a_type safetyguard_a;

   typedef uint8_t _e_stop_type;
  _e_stop_type e_stop;

   typedef uint8_t _camera_light_type;
  _camera_light_type camera_light;

   typedef int32_t _error_code_type;
  _error_code_type error_code;

   typedef int32_t _project_speed_type;
  _project_speed_type project_speed;

   typedef int32_t _ma_mode_type;
  _ma_mode_type ma_mode;

   typedef int32_t _robot_light_type;
  _robot_light_type robot_light;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _cb_digital_output_type;
  _cb_digital_output_type cb_digital_output;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _cb_digital_input_type;
  _cb_digital_input_type cb_digital_input;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _cb_analog_output_type;
  _cb_analog_output_type cb_analog_output;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _cb_analog_input_type;
  _cb_analog_input_type cb_analog_input;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _ee_digital_output_type;
  _ee_digital_output_type ee_digital_output;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _ee_digital_input_type;
  _ee_digital_input_type ee_digital_input;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _ee_analog_output_type;
  _ee_analog_output_type ee_analog_output;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _ee_analog_input_type;
  _ee_analog_input_type ee_analog_input;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _error_content_type;
  _error_content_type error_content;





  typedef boost::shared_ptr< ::tm_msgs::FeedbackState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::tm_msgs::FeedbackState_<ContainerAllocator> const> ConstPtr;

}; // struct FeedbackState_

typedef ::tm_msgs::FeedbackState_<std::allocator<void> > FeedbackState;

typedef boost::shared_ptr< ::tm_msgs::FeedbackState > FeedbackStatePtr;
typedef boost::shared_ptr< ::tm_msgs::FeedbackState const> FeedbackStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::tm_msgs::FeedbackState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::tm_msgs::FeedbackState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::tm_msgs::FeedbackState_<ContainerAllocator1> & lhs, const ::tm_msgs::FeedbackState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.is_svr_connected == rhs.is_svr_connected &&
    lhs.is_sct_connected == rhs.is_sct_connected &&
    lhs.tmsrv_cperr == rhs.tmsrv_cperr &&
    lhs.tmscript_cperr == rhs.tmscript_cperr &&
    lhs.tmsrv_dataerr == rhs.tmsrv_dataerr &&
    lhs.tmscript_dataerr == rhs.tmscript_dataerr &&
    lhs.max_not_connect_in_s == rhs.max_not_connect_in_s &&
    lhs.disconnection_times == rhs.disconnection_times &&
    lhs.joint_pos == rhs.joint_pos &&
    lhs.joint_vel == rhs.joint_vel &&
    lhs.joint_tor == rhs.joint_tor &&
    lhs.tool0_pose == rhs.tool0_pose &&
    lhs.tool_pose == rhs.tool_pose &&
    lhs.tcp_speed == rhs.tcp_speed &&
    lhs.tcp_force == rhs.tcp_force &&
    lhs.joint_tor_average == rhs.joint_tor_average &&
    lhs.joint_tor_min == rhs.joint_tor_min &&
    lhs.joint_tor_max == rhs.joint_tor_max &&
    lhs.robot_link == rhs.robot_link &&
    lhs.is_data_table_correct == rhs.is_data_table_correct &&
    lhs.robot_error == rhs.robot_error &&
    lhs.project_run == rhs.project_run &&
    lhs.project_pause == rhs.project_pause &&
    lhs.safetyguard_a == rhs.safetyguard_a &&
    lhs.e_stop == rhs.e_stop &&
    lhs.camera_light == rhs.camera_light &&
    lhs.error_code == rhs.error_code &&
    lhs.project_speed == rhs.project_speed &&
    lhs.ma_mode == rhs.ma_mode &&
    lhs.robot_light == rhs.robot_light &&
    lhs.cb_digital_output == rhs.cb_digital_output &&
    lhs.cb_digital_input == rhs.cb_digital_input &&
    lhs.cb_analog_output == rhs.cb_analog_output &&
    lhs.cb_analog_input == rhs.cb_analog_input &&
    lhs.ee_digital_output == rhs.ee_digital_output &&
    lhs.ee_digital_input == rhs.ee_digital_input &&
    lhs.ee_analog_output == rhs.ee_analog_output &&
    lhs.ee_analog_input == rhs.ee_analog_input &&
    lhs.error_content == rhs.error_content;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::tm_msgs::FeedbackState_<ContainerAllocator1> & lhs, const ::tm_msgs::FeedbackState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace tm_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::tm_msgs::FeedbackState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::tm_msgs::FeedbackState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::tm_msgs::FeedbackState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::tm_msgs::FeedbackState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tm_msgs::FeedbackState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tm_msgs::FeedbackState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::tm_msgs::FeedbackState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "44d5702d5a7507d317011ef00404b814";
  }

  static const char* value(const ::tm_msgs::FeedbackState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x44d5702d5a7507d3ULL;
  static const uint64_t static_value2 = 0x17011ef00404b814ULL;
};

template<class ContainerAllocator>
struct DataType< ::tm_msgs::FeedbackState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "tm_msgs/FeedbackState";
  }

  static const char* value(const ::tm_msgs::FeedbackState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::tm_msgs::FeedbackState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"# Connection Status\n"
"bool is_svr_connected       # Ethernet connection\n"
"bool is_sct_connected       # Listen Node connection\n"
"\n"
"# Response ROS Node Status\n"
"int32 tmsrv_cperr           # TM Ethernet Slave Communication Last CPERR Error Code\n"
"int32 tmscript_cperr        # External Script Communication Last CPERR Error Code\n"
"int32 tmsrv_dataerr         # TMSVR Communication Last Data Error Code\n"
"int32 tmscript_dataerr      # External Script Communication TMSCT (or TMSTA) Last Data Error Code\n"
"\n"
"# Disconnection Message\n"
"int32 max_not_connect_in_s\n"
"int32 disconnection_times\n"
"\n"
"# Movement\n"
"float64[] joint_pos\n"
"float64[] joint_vel\n"
"float64[] joint_tor\n"
"float64[] tool0_pose\n"
"float64[] tool_pose\n"
"float64[] tcp_speed\n"
"float64[] tcp_force\n"
"\n"
"# Torque Data(for TM-Flow 1.84)\n"
"float64[] joint_tor_average\n"
"float64[] joint_tor_min\n"
"float64[] joint_tor_max\n"
"\n"
"# Status\n"
"bool robot_link              # Link Robot Controller\n"
"bool is_data_table_correct   # Data Table Setting is Correct\n"
"bool robot_error             # Error or Not\n"
"bool project_run             # Project Runing or not\n"
"bool project_pause           # Project Pause or not\n"
"bool safetyguard_a           # Safety IO(Safeguard Port A trigger) \n"
"bool e_stop                  # Emergency STOP\n"
"bool camera_light            # Light\n"
"int32 error_code             # Last Error Code\n"
"int32 project_speed          # Project Running Speed\n"
"int32 ma_mode                # M/A Mode\n"
"int32 robot_light            # Robot light\n"
"\n"
"# IO\n"
"bool[] cb_digital_output\n"
"bool[] cb_digital_input\n"
"float32[] cb_analog_output\n"
"float32[] cb_analog_input\n"
"bool[] ee_digital_output\n"
"bool[] ee_digital_input\n"
"float32[] ee_analog_output\n"
"float32[] ee_analog_input\n"
"\n"
"# String\n"
"string error_content\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::tm_msgs::FeedbackState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::tm_msgs::FeedbackState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.is_svr_connected);
      stream.next(m.is_sct_connected);
      stream.next(m.tmsrv_cperr);
      stream.next(m.tmscript_cperr);
      stream.next(m.tmsrv_dataerr);
      stream.next(m.tmscript_dataerr);
      stream.next(m.max_not_connect_in_s);
      stream.next(m.disconnection_times);
      stream.next(m.joint_pos);
      stream.next(m.joint_vel);
      stream.next(m.joint_tor);
      stream.next(m.tool0_pose);
      stream.next(m.tool_pose);
      stream.next(m.tcp_speed);
      stream.next(m.tcp_force);
      stream.next(m.joint_tor_average);
      stream.next(m.joint_tor_min);
      stream.next(m.joint_tor_max);
      stream.next(m.robot_link);
      stream.next(m.is_data_table_correct);
      stream.next(m.robot_error);
      stream.next(m.project_run);
      stream.next(m.project_pause);
      stream.next(m.safetyguard_a);
      stream.next(m.e_stop);
      stream.next(m.camera_light);
      stream.next(m.error_code);
      stream.next(m.project_speed);
      stream.next(m.ma_mode);
      stream.next(m.robot_light);
      stream.next(m.cb_digital_output);
      stream.next(m.cb_digital_input);
      stream.next(m.cb_analog_output);
      stream.next(m.cb_analog_input);
      stream.next(m.ee_digital_output);
      stream.next(m.ee_digital_input);
      stream.next(m.ee_analog_output);
      stream.next(m.ee_analog_input);
      stream.next(m.error_content);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct FeedbackState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::tm_msgs::FeedbackState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::tm_msgs::FeedbackState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "is_svr_connected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_svr_connected);
    s << indent << "is_sct_connected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_sct_connected);
    s << indent << "tmsrv_cperr: ";
    Printer<int32_t>::stream(s, indent + "  ", v.tmsrv_cperr);
    s << indent << "tmscript_cperr: ";
    Printer<int32_t>::stream(s, indent + "  ", v.tmscript_cperr);
    s << indent << "tmsrv_dataerr: ";
    Printer<int32_t>::stream(s, indent + "  ", v.tmsrv_dataerr);
    s << indent << "tmscript_dataerr: ";
    Printer<int32_t>::stream(s, indent + "  ", v.tmscript_dataerr);
    s << indent << "max_not_connect_in_s: ";
    Printer<int32_t>::stream(s, indent + "  ", v.max_not_connect_in_s);
    s << indent << "disconnection_times: ";
    Printer<int32_t>::stream(s, indent + "  ", v.disconnection_times);
    s << indent << "joint_pos[]" << std::endl;
    for (size_t i = 0; i < v.joint_pos.size(); ++i)
    {
      s << indent << "  joint_pos[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_pos[i]);
    }
    s << indent << "joint_vel[]" << std::endl;
    for (size_t i = 0; i < v.joint_vel.size(); ++i)
    {
      s << indent << "  joint_vel[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_vel[i]);
    }
    s << indent << "joint_tor[]" << std::endl;
    for (size_t i = 0; i < v.joint_tor.size(); ++i)
    {
      s << indent << "  joint_tor[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_tor[i]);
    }
    s << indent << "tool0_pose[]" << std::endl;
    for (size_t i = 0; i < v.tool0_pose.size(); ++i)
    {
      s << indent << "  tool0_pose[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tool0_pose[i]);
    }
    s << indent << "tool_pose[]" << std::endl;
    for (size_t i = 0; i < v.tool_pose.size(); ++i)
    {
      s << indent << "  tool_pose[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tool_pose[i]);
    }
    s << indent << "tcp_speed[]" << std::endl;
    for (size_t i = 0; i < v.tcp_speed.size(); ++i)
    {
      s << indent << "  tcp_speed[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tcp_speed[i]);
    }
    s << indent << "tcp_force[]" << std::endl;
    for (size_t i = 0; i < v.tcp_force.size(); ++i)
    {
      s << indent << "  tcp_force[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tcp_force[i]);
    }
    s << indent << "joint_tor_average[]" << std::endl;
    for (size_t i = 0; i < v.joint_tor_average.size(); ++i)
    {
      s << indent << "  joint_tor_average[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_tor_average[i]);
    }
    s << indent << "joint_tor_min[]" << std::endl;
    for (size_t i = 0; i < v.joint_tor_min.size(); ++i)
    {
      s << indent << "  joint_tor_min[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_tor_min[i]);
    }
    s << indent << "joint_tor_max[]" << std::endl;
    for (size_t i = 0; i < v.joint_tor_max.size(); ++i)
    {
      s << indent << "  joint_tor_max[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_tor_max[i]);
    }
    s << indent << "robot_link: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.robot_link);
    s << indent << "is_data_table_correct: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_data_table_correct);
    s << indent << "robot_error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.robot_error);
    s << indent << "project_run: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.project_run);
    s << indent << "project_pause: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.project_pause);
    s << indent << "safetyguard_a: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.safetyguard_a);
    s << indent << "e_stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.e_stop);
    s << indent << "camera_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.camera_light);
    s << indent << "error_code: ";
    Printer<int32_t>::stream(s, indent + "  ", v.error_code);
    s << indent << "project_speed: ";
    Printer<int32_t>::stream(s, indent + "  ", v.project_speed);
    s << indent << "ma_mode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ma_mode);
    s << indent << "robot_light: ";
    Printer<int32_t>::stream(s, indent + "  ", v.robot_light);
    s << indent << "cb_digital_output[]" << std::endl;
    for (size_t i = 0; i < v.cb_digital_output.size(); ++i)
    {
      s << indent << "  cb_digital_output[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.cb_digital_output[i]);
    }
    s << indent << "cb_digital_input[]" << std::endl;
    for (size_t i = 0; i < v.cb_digital_input.size(); ++i)
    {
      s << indent << "  cb_digital_input[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.cb_digital_input[i]);
    }
    s << indent << "cb_analog_output[]" << std::endl;
    for (size_t i = 0; i < v.cb_analog_output.size(); ++i)
    {
      s << indent << "  cb_analog_output[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.cb_analog_output[i]);
    }
    s << indent << "cb_analog_input[]" << std::endl;
    for (size_t i = 0; i < v.cb_analog_input.size(); ++i)
    {
      s << indent << "  cb_analog_input[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.cb_analog_input[i]);
    }
    s << indent << "ee_digital_output[]" << std::endl;
    for (size_t i = 0; i < v.ee_digital_output.size(); ++i)
    {
      s << indent << "  ee_digital_output[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.ee_digital_output[i]);
    }
    s << indent << "ee_digital_input[]" << std::endl;
    for (size_t i = 0; i < v.ee_digital_input.size(); ++i)
    {
      s << indent << "  ee_digital_input[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.ee_digital_input[i]);
    }
    s << indent << "ee_analog_output[]" << std::endl;
    for (size_t i = 0; i < v.ee_analog_output.size(); ++i)
    {
      s << indent << "  ee_analog_output[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.ee_analog_output[i]);
    }
    s << indent << "ee_analog_input[]" << std::endl;
    for (size_t i = 0; i < v.ee_analog_input.size(); ++i)
    {
      s << indent << "  ee_analog_input[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.ee_analog_input[i]);
    }
    s << indent << "error_content: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.error_content);
  }
};

} // namespace message_operations
} // namespace ros

#endif // TM_MSGS_MESSAGE_FEEDBACKSTATE_H
